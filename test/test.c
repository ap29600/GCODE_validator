#define _XOPEN_SOURCE 700
#include "../lib/picotest.h"
#include "../src/lexer.c"
#include "../src/whitelist.c"

const char gcode_buf[] =
    "; generated by PrusaSlicer 2.1.1 on 2020-09-05 at 19:14:33 UTC\n"
    "\n"
    ";\n"
    "\n"
    "; external perimeters extrusion width = 0.39mm\n"
    "; perimeters extrusion width = 0.39mm\n"
    "; infill extrusion width = 0.39mm\n"
    "; solid infill extrusion width = 0.39mm\n"
    "; top infill extrusion width = 0.35mm\n"
    "; first layer extrusion width = 0.37mm\n"
    "\n"
    "M201 X9000 Y9000 Z500 E10000 ; sets maximum accelerations, mm/sec^2\n"
    "M203 X500 Y500 Z12 E120 ; sets maximum feedrates, mm/sec\n"
    "M204 P1500 R1500 T1500 ; sets acceleration (P, T) and retract acceleration (R), mm/sec^2\n"
    "M205 X10.00 Y10.00 Z0.20 E2.50 ; sets the jerk limits, mm/sec\n"
    "M205 S0 T0 ; sets the minimum extruding and travel feed rate, mm/sec\n"
    "M107\n"
    "M190 S70 ; set bed temperature and wait for it to be reached\n"
    "M104 S235 ; set temperature\n"
    "G28 ; home all axes\n"
    "G1 Z5 F5000 ; lift nozzle\n"
    "M109 S235 ; set temperature and wait for it to be reached\n"
    "G21 ; set units to millimeters\n"
    "G90 ; use absolute coordinates\n"
    "M82 ; use absolute distances for extrusion\n"
    "G92 E0\n"
    "; Filament gcode\n"
    "G1 Z0.350 F7800.000\n"
    "G1 E-2.00000 F2400.00000\n"
    "G92 E0\n"
    "G1 X21.102 Y-27.921 F7800.000\n"
    "G1 E2.00000 F2400.00000\n"
    "G1 F1800\n"
    "G1 X21.867 Y-26.564 E2.06685\n"
    "G1 X22.200 Y-25.450 E2.11671\n"
    "G1 X22.318 Y-24.294 E2.16658\n"
    "G1 X22.311 Y36.056 E4.75624\n"
    "G1 X22.206 Y36.919 E4.79353\n"
    "G1 X21.981 Y37.759 E4.83083\n";

const string_view const_gcode_slice = { .data = gcode_buf, .len = sizeof gcode_buf - 1 };

void tokenize_file() {
  INIT;

  char *expected_tokens[] = {
      "M201",   
      "X9000",
      "Y9000",
      "Z500",
      "E10000",
      "M203",
      "X500",
      "Y500",
      "Z12",
      "E120",
      "M204",
      "P1500",
      "R1500",
      "T1500",
      "M205",
      "X10.00",
      "Y10.00",
      "Z0.20",
      "E2.50"
    };
  size_t len = sizeof expected_tokens / sizeof expected_tokens[0];
  string_view gcode = const_gcode_slice;
  for (size_t i = 0; i < len; i++) {
    Token token = next_token(&gcode);
    ASSERT_EQ(token.sv, sv_from_str(expected_tokens[i]))
  }

  REPORT;
}

void token_decoding() {
  INIT;
  Command commands[] = {
      {CMD_M,    201,   {0, 0}},
	  {SUBCMD_X, 9000,  {0, 0}},
      {SUBCMD_Y, 9000,  {0, 0}},
	  {SUBCMD_Z, 500,   {0, 0}},
      {SUBCMD_E, 10000, {0, 0}},
	  {CMD_M,    203,   {0, 0}},
      {SUBCMD_X, 500,   {0, 0}},
	  {SUBCMD_Y, 500,   {0, 0}},
      {SUBCMD_Z, 12,    {0, 0}},
	  {SUBCMD_E, 120,   {0, 0}},
      {CMD_M,    204,   {0, 0}},
	  {SUBCMD_P, 1500,  {0, 0}},
      {SUBCMD_R, 1500,  {0, 0}},
	  {SUBCMD_T, 1500,  {0, 0}},
      {CMD_M,    205,   {0, 0}},
	  {SUBCMD_X, 10.00, {0, 0}},
      {SUBCMD_Y, 10.00, {0, 0}},
	  {SUBCMD_Z, 0.20,  {0, 0}},
      {SUBCMD_E, 2.50,  {0, 0}}
    };
  size_t len = sizeof commands / sizeof commands[0];
  string_view gcode = const_gcode_slice;

  for (size_t i = 0; i < len; i++) {
    Command command = next_command(&gcode);

    ASSERT_EQ(command.variant, commands[i].variant);
    ASSERT_EQ(command.value, commands[i].value);

    if (command.variant != commands[i].variant) {
        printf("%zu\n", i);
    }
  }

  REPORT;
}

void whitelist_generation() {
  INIT;

  const list_entry expected_whitelist[] = {
      { cmd_to_id((Command){ CMD_G, 1.0 , {0} }), 
          (1 << (SUBCMD_X & VAL_MASK)) |
          (1 << (SUBCMD_Y & VAL_MASK)) | 
          (1 << (SUBCMD_Z & VAL_MASK)) | 
          (1 << (SUBCMD_E & VAL_MASK)) |
          (1 << (SUBCMD_F & VAL_MASK))
      },
      { cmd_to_id((Command){ CMD_G, 21.0,  {0} }), 0x00000000                   },
      { cmd_to_id((Command){ CMD_G, 28.0,  {0} }), 0x00000000                   },
      { cmd_to_id((Command){ CMD_G, 90.0,  {0} }), 0x00000000                   },
      { cmd_to_id((Command){ CMD_G, 92.0,  {0} }), (1 << (SUBCMD_E & VAL_MASK)) },
      { cmd_to_id((Command){ CMD_M, 82.0,  {0} }), 0x00000000                   },
      { cmd_to_id((Command){ CMD_M, 104.0, {0} }), (1 << (SUBCMD_S & VAL_MASK)) },
      { cmd_to_id((Command){ CMD_M, 107.0, {0} }), 0x00000000                   },
      { cmd_to_id((Command){ CMD_M, 109.0, {0} }), (1 << (SUBCMD_S & VAL_MASK)) },
      { cmd_to_id((Command){ CMD_M, 190.0, {0} }), (1 << (SUBCMD_S & VAL_MASK)) },
      { cmd_to_id((Command){ CMD_M, 201.0, {0} }),
          (1 << (SUBCMD_X & VAL_MASK)) |
          (1 << (SUBCMD_Y & VAL_MASK)) | 
          (1 << (SUBCMD_Z & VAL_MASK)) | 
          (1 << (SUBCMD_E & VAL_MASK)) ,
      },
      { cmd_to_id((Command){ CMD_M, 203.0, {0} }),
          (1 << (SUBCMD_X & VAL_MASK)) |
          (1 << (SUBCMD_Y & VAL_MASK)) | 
          (1 << (SUBCMD_Z & VAL_MASK)) | 
          (1 << (SUBCMD_E & VAL_MASK)) ,
      },
      { cmd_to_id((Command){ CMD_M, 204.0, {0} }),
          (1 << (SUBCMD_P & VAL_MASK)) |
          (1 << (SUBCMD_R & VAL_MASK)) | 
          (1 << (SUBCMD_T & VAL_MASK)) ,
      },
      { cmd_to_id((Command){ CMD_M, 205.0, {0} }),
          (1 << (SUBCMD_X & VAL_MASK)) |
          (1 << (SUBCMD_Y & VAL_MASK)) | 
          (1 << (SUBCMD_Z & VAL_MASK)) | 
          (1 << (SUBCMD_E & VAL_MASK)) |
          (1 << (SUBCMD_S & VAL_MASK)) |
          (1 << (SUBCMD_T & VAL_MASK)) ,
      },
  };

  size_t len = sizeof expected_whitelist / sizeof expected_whitelist[0];
  string_view gcode = const_gcode_slice;

  cmdlist generated_whitelist = build_whitelist(gcode);

  ASSERT_EQ (generated_whitelist.size, len);
  if (generated_whitelist.size < len)
      len = generated_whitelist.size;

  for (size_t i = 0; i < len; i++) {
      Command cmd = id_to_cmd(generated_whitelist.data[i].id);
      Command expected_cmd = id_to_cmd(expected_whitelist[i].id);
      ASSERT_EQ(cmd.variant, expected_cmd.variant);
      ASSERT_EQ(cmd.value, expected_cmd.value);
      ASSERT_EQ(generated_whitelist.data[i].subcommands, expected_whitelist[i].subcommands);
  }
  REPORT;
}

int main() {
  tokenize_file();
  token_decoding();
  whitelist_generation();
}
